{"version":3,"file":"index-nbCOwjJR.js","sources":["../../node_modules/.pnpm/@solid-primitives+list@0.1.0_solid-js@1.9.4/node_modules/@solid-primitives/list/dist/index.js"],"sourcesContent":["import { createSignal, onCleanup, $TRACK, untrack, createRoot, batch, createMemo, } from \"solid-js\";\nimport { isDev } from \"solid-js/web\";\nfunction disposeList(list) {\n    for (let i = 0; i < list.length; i++) {\n        list[i]?.disposer();\n    }\n}\n/**\n * Reactively transforms an array with a callback function - underlying helper for the `<List>` unkeyed control flow.\n *\n * Alternative to `mapArray` or `indexArray` that provides reactive value and index for array elements.\n */\nexport function listArray(list, mapFn, options = {}) {\n    const items = [];\n    let mapped = [], unusedItems, i, j, item, oldValue, oldIndex, newValue, fallback, fallbackDisposer;\n    onCleanup(() => {\n        fallbackDisposer?.();\n        fallbackDisposer = undefined;\n        disposeList(items);\n    });\n    return () => {\n        const newItems = list() || [];\n        newItems[$TRACK]; // top level tracking\n        return untrack(() => {\n            if (newItems.length > 0 && fallbackDisposer) {\n                fallbackDisposer();\n                fallbackDisposer = undefined;\n                fallback = undefined;\n            }\n            const temp = new Array(newItems.length); // new mapped array\n            unusedItems = items.length;\n            // 1) no change when values & indexes match\n            for (j = unusedItems - 1; j >= 0; --j) {\n                item = items[j];\n                oldIndex = item.index;\n                if (oldIndex < newItems.length && newItems[oldIndex] === item.value) {\n                    temp[oldIndex] = mapped[oldIndex];\n                    if (--unusedItems !== j) {\n                        items[j] = items[unusedItems];\n                        items[unusedItems] = item;\n                    }\n                }\n            }\n            // #2 prepare values matcher\n            const matcher = new Map();\n            const matchedItems = new Uint8Array(unusedItems);\n            for (j = unusedItems - 1; j >= 0; --j) {\n                oldValue = items[j].value;\n                matcher.get(oldValue)?.push(j) ?? matcher.set(oldValue, [j]);\n            }\n            // 2) change indexes when values match\n            for (i = 0; i < newItems.length; ++i) {\n                if (i in temp)\n                    continue;\n                newValue = newItems[i];\n                j = matcher.get(newValue)?.pop() ?? -1;\n                if (j >= 0) {\n                    item = items[j];\n                    oldIndex = item.index;\n                    temp[i] = mapped[oldIndex];\n                    item.index = i;\n                    item.indexSetter?.(i);\n                    matchedItems[j] = 1;\n                }\n            }\n            // #2 reduce unusedItems for matched items\n            for (j = matchedItems.length - 1; j >= 0; --j) {\n                if (matchedItems[j] && --unusedItems !== j) {\n                    item = items[j];\n                    items[j] = items[unusedItems];\n                    items[unusedItems] = item;\n                }\n            }\n            // 3) change values when indexes match\n            for (j = unusedItems - 1; j >= 0; --j) {\n                item = items[j];\n                oldIndex = item.index;\n                if (!(oldIndex in temp) && oldIndex < newItems.length) {\n                    temp[oldIndex] = mapped[oldIndex];\n                    newValue = newItems[oldIndex];\n                    item.value = newValue;\n                    item.valueSetter?.(newValueGetter);\n                    if (--unusedItems !== j) {\n                        items[j] = items[unusedItems];\n                        items[unusedItems] = item;\n                    }\n                }\n            }\n            // 4) change value & index when none matched\n            // 5) create new if no unused items left\n            for (i = 0; i < newItems.length; ++i) {\n                if (i in temp)\n                    continue;\n                newValue = newItems[i];\n                if (unusedItems > 0) {\n                    item = items[--unusedItems];\n                    temp[i] = mapped[item.index];\n                    batch(changeBoth);\n                }\n                else {\n                    temp[i] = createRoot(mapper);\n                }\n            }\n            // 6) delete any old unused items left\n            disposeList(items.splice(0, unusedItems));\n            if (newItems.length === 0 && options.fallback) {\n                if (!fallbackDisposer) {\n                    fallback = [\n                        createRoot(d => {\n                            fallbackDisposer = d;\n                            return options.fallback();\n                        }),\n                    ];\n                }\n                return fallback;\n            }\n            return (mapped = temp);\n        });\n    };\n    function newValueGetter() {\n        return newValue;\n    }\n    function changeBoth() {\n        item.index = i;\n        item.indexSetter?.(i);\n        item.value = newValue;\n        item.valueSetter?.(newValueGetter);\n    }\n    function mapper(disposer) {\n        const t = {\n            value: newValue,\n            index: i,\n            disposer,\n        }, scopedV = newValue, scopedI = i;\n        items.push(t);\n        // signal created when used\n        let sV = () => {\n            [sV, t.valueSetter] = isDev\n                ? createSignal(scopedV, { name: \"value\" })\n                : createSignal(scopedV);\n            return sV();\n        }, sI = () => {\n            [sI, t.indexSetter] = isDev\n                ? createSignal(scopedI, { name: \"index\" })\n                : createSignal(scopedI);\n            return sI();\n        };\n        return mapFn(() => sV(), () => sI());\n    }\n}\n/**\n * Iteration over a list creating elements from its items.\n * It avoids recreating elements, instead reorders existing elements whenever possible and / or changes reactive value.\n *\n * To be used if you have a list with changing indexes and values.\n * ```typescript\n * <List each={items} fallback={<div>No items</div>}>\n *   {(item, index) => <div data-index={index()}>{item()}</div>}\n * </List>\n * ```\n */\nexport function List(props) {\n    const fallback = \"fallback\" in props && { fallback: () => props.fallback };\n    return (isDev\n        ? createMemo(listArray(() => props.each, props.children, fallback || undefined), undefined, { name: \"value\" })\n        : createMemo(listArray(() => props.each, props.children, fallback || undefined)));\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}