{"version":3,"file":"index-legacy-rVLbJTER.js","sources":["../../node_modules/.pnpm/@solid-primitives+list@0.1.0_solid-js@1.9.4/node_modules/@solid-primitives/list/dist/index.js"],"sourcesContent":["import { createSignal, onCleanup, $TRACK, untrack, createRoot, batch, createMemo, } from \"solid-js\";\nimport { isDev } from \"solid-js/web\";\nfunction disposeList(list) {\n    for (let i = 0; i < list.length; i++) {\n        list[i]?.disposer();\n    }\n}\n/**\n * Reactively transforms an array with a callback function - underlying helper for the `<List>` unkeyed control flow.\n *\n * Alternative to `mapArray` or `indexArray` that provides reactive value and index for array elements.\n */\nexport function listArray(list, mapFn, options = {}) {\n    const items = [];\n    let mapped = [], unusedItems, i, j, item, oldValue, oldIndex, newValue, fallback, fallbackDisposer;\n    onCleanup(() => {\n        fallbackDisposer?.();\n        fallbackDisposer = undefined;\n        disposeList(items);\n    });\n    return () => {\n        const newItems = list() || [];\n        newItems[$TRACK]; // top level tracking\n        return untrack(() => {\n            if (newItems.length > 0 && fallbackDisposer) {\n                fallbackDisposer();\n                fallbackDisposer = undefined;\n                fallback = undefined;\n            }\n            const temp = new Array(newItems.length); // new mapped array\n            unusedItems = items.length;\n            // 1) no change when values & indexes match\n            for (j = unusedItems - 1; j >= 0; --j) {\n                item = items[j];\n                oldIndex = item.index;\n                if (oldIndex < newItems.length && newItems[oldIndex] === item.value) {\n                    temp[oldIndex] = mapped[oldIndex];\n                    if (--unusedItems !== j) {\n                        items[j] = items[unusedItems];\n                        items[unusedItems] = item;\n                    }\n                }\n            }\n            // #2 prepare values matcher\n            const matcher = new Map();\n            const matchedItems = new Uint8Array(unusedItems);\n            for (j = unusedItems - 1; j >= 0; --j) {\n                oldValue = items[j].value;\n                matcher.get(oldValue)?.push(j) ?? matcher.set(oldValue, [j]);\n            }\n            // 2) change indexes when values match\n            for (i = 0; i < newItems.length; ++i) {\n                if (i in temp)\n                    continue;\n                newValue = newItems[i];\n                j = matcher.get(newValue)?.pop() ?? -1;\n                if (j >= 0) {\n                    item = items[j];\n                    oldIndex = item.index;\n                    temp[i] = mapped[oldIndex];\n                    item.index = i;\n                    item.indexSetter?.(i);\n                    matchedItems[j] = 1;\n                }\n            }\n            // #2 reduce unusedItems for matched items\n            for (j = matchedItems.length - 1; j >= 0; --j) {\n                if (matchedItems[j] && --unusedItems !== j) {\n                    item = items[j];\n                    items[j] = items[unusedItems];\n                    items[unusedItems] = item;\n                }\n            }\n            // 3) change values when indexes match\n            for (j = unusedItems - 1; j >= 0; --j) {\n                item = items[j];\n                oldIndex = item.index;\n                if (!(oldIndex in temp) && oldIndex < newItems.length) {\n                    temp[oldIndex] = mapped[oldIndex];\n                    newValue = newItems[oldIndex];\n                    item.value = newValue;\n                    item.valueSetter?.(newValueGetter);\n                    if (--unusedItems !== j) {\n                        items[j] = items[unusedItems];\n                        items[unusedItems] = item;\n                    }\n                }\n            }\n            // 4) change value & index when none matched\n            // 5) create new if no unused items left\n            for (i = 0; i < newItems.length; ++i) {\n                if (i in temp)\n                    continue;\n                newValue = newItems[i];\n                if (unusedItems > 0) {\n                    item = items[--unusedItems];\n                    temp[i] = mapped[item.index];\n                    batch(changeBoth);\n                }\n                else {\n                    temp[i] = createRoot(mapper);\n                }\n            }\n            // 6) delete any old unused items left\n            disposeList(items.splice(0, unusedItems));\n            if (newItems.length === 0 && options.fallback) {\n                if (!fallbackDisposer) {\n                    fallback = [\n                        createRoot(d => {\n                            fallbackDisposer = d;\n                            return options.fallback();\n                        }),\n                    ];\n                }\n                return fallback;\n            }\n            return (mapped = temp);\n        });\n    };\n    function newValueGetter() {\n        return newValue;\n    }\n    function changeBoth() {\n        item.index = i;\n        item.indexSetter?.(i);\n        item.value = newValue;\n        item.valueSetter?.(newValueGetter);\n    }\n    function mapper(disposer) {\n        const t = {\n            value: newValue,\n            index: i,\n            disposer,\n        }, scopedV = newValue, scopedI = i;\n        items.push(t);\n        // signal created when used\n        let sV = () => {\n            [sV, t.valueSetter] = isDev\n                ? createSignal(scopedV, { name: \"value\" })\n                : createSignal(scopedV);\n            return sV();\n        }, sI = () => {\n            [sI, t.indexSetter] = isDev\n                ? createSignal(scopedI, { name: \"index\" })\n                : createSignal(scopedI);\n            return sI();\n        };\n        return mapFn(() => sV(), () => sI());\n    }\n}\n/**\n * Iteration over a list creating elements from its items.\n * It avoids recreating elements, instead reorders existing elements whenever possible and / or changes reactive value.\n *\n * To be used if you have a list with changing indexes and values.\n * ```typescript\n * <List each={items} fallback={<div>No items</div>}>\n *   {(item, index) => <div data-index={index()}>{item()}</div>}\n * </List>\n * ```\n */\nexport function List(props) {\n    const fallback = \"fallback\" in props && { fallback: () => props.fallback };\n    return (isDev\n        ? createMemo(listArray(() => props.each, props.children, fallback || undefined), undefined, { name: \"value\" })\n        : createMemo(listArray(() => props.each, props.children, fallback || undefined)));\n}\n"],"names":["disposeList","list","i","length","_list$i","disposer","listArray","mapFn","options","arguments","undefined","items","mapped","unusedItems","j","item","oldValue","oldIndex","newValue","fallback","fallbackDisposer","onCleanup","_fallbackDisposer","newItems","$TRACK","untrack","temp","Array","index","value","matcher","Map","matchedItems","Uint8Array","_matcher$get$push","_matcher$get","get","push","set","_matcher$get$pop","_matcher$get2","pop","_item$indexSetter","_item","indexSetter","call","_item$valueSetter","_item2","valueSetter","newValueGetter","batch","changeBoth","createRoot","mapper","splice","d","_item$indexSetter2","_item3","_item$valueSetter2","_item4","t","scopedV","scopedI","sV","_createSignal","createSignal","_createSignal2","_slicedToArray","sI","_createSignal3","_createSignal4","List","props","createMemo","each","children"],"mappings":"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","x_google_ignoreList":[0]}